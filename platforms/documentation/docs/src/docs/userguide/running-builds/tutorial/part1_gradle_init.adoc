// Copyright (C) 2023 Gradle, Inc.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[part1_gradle_init]]
= Part 1: Initializing the Project

Learn the basics of Gradle by creating a Java app using Gradle init.

****
**In this section you will:**

- Initialize a new Gradle project
- Build the project
- Review Gradle's project structure
- Open the project in IntelliJ IDEA
- Explore Gradle files and build scripts
- Understand the Gradle wrapper
****

[[part1_begin]]
== Step 0. Before you Begin

1. Make sure you have <<installation.adoc#installation,Gradle installed>>.

2. Install link:https://www.jetbrains.com/idea/download/[IntelliJ IDEA].
The Community Edition is a free version of IntelliJ IDEA.

== Step 1. Initializing the Project
To test the Gradle installation, run Gradle from the command-line:
[source,text]
----
$ gradle

Welcome to Gradle 8.6.

Directory '/' does not contain a Gradle build.

To create a new build in this directory, run gradle init
----

If Gradle is not installed, please refer to the <<installation.adoc#installation, installation section>>.

Create a new directory called `tutorial` and `cd` into it:
[source,text]
----
$ mkdir tutorial
----
[source,text]
----
$ cd tutorial
----

Run `gradle init` with parameters to generate a Java application:
[source,text]
----
$ gradle init --use-defaults --type java-application
----

NOTE: In this tutorial, Kotlin DSL is used to build a simple Java project (as it is the default DSL starting in Gradle 8.2). All examples are macOS based.

When you are done, the directory should look as follows:

----
├── .gradle             // <1>
│   └── ⋮
├── gradle              // <2>
│   └── wrapper
├── gradlew             // <3>
├── gradlew.bat         // <4>
├── settings.gradle.kts // <5>
├── app                 // <6>
│   ├── build.gradle.kts
│   └── src
└── ⋮                   // <7>

----
<1> Project-specific cache directory generated by Gradle.
<2> Contains the JAR file and configuration of the <<gradle_wrapper.adoc#gradle_wrapper,Gradle Wrapper>>.
<3> macOS and Linux script for executing builds using the <<gradle_wrapper.adoc#gradle_wrapper,Gradle Wrapper>>.
<4> Windows script for executing builds using the <<gradle_wrapper.adoc#gradle_wrapper,Gradle Wrapper>>.
<5> The project's <<organizing_gradle_projects.adoc#sec:settings_file, settings file>> where the list of subprojects is defined.
<6> The source code and build configuration for the Java app.
<7> Some additional Git files may be present such as `.gitignore`.

== Step 2. Understanding the Gradle Wrapper
The Gradle Wrapper is the preferred way of starting a Gradle build.
The Wrapper downloads (if needed) and then invokes a specific version of Gradle declared in the build.

In your newly created project, take a look at the files used by the Gradle Wrapper first.
It consists of a shell script for macOS and Linux +++<i class="conum" data-value="3"></i>+++ and a batch script for Windows +++<i class="conum" data-value="4"></i>+++.

These scripts allow you to run a Gradle build without requiring that Gradle be installed on your system.
It also helps ensure that the same version of Gradle is used for builds by different developers and between local and CI machines.

From now on, you will never invoke Gradle directly; instead, you will use the Gradle _wrapper_.

== Step 3. Invoking the Gradle Wrapper
Use the wrapper by entering the following command:
[source,text]
----
$ ./gradlew build
----

In Windows, the command is:
[source,text]
----
$ .\gradlew.bat build
----

The first time you run the wrapper, it downloads and caches the Gradle binaries if they are not already installed on your machine.

The Gradle Wrapper is designed to be committed to source control so that anyone can build the project without having to first install and configure a specific version of Gradle.

In this case, we invoked Gradle through the wrapper to build our project, so we can see that the `app` directory now includes a new `build` folder:
[source,text]
----
$ cd app
----
[source,text]
----
$ ls -al
----
----
drwxr-xr-x  10 gradle-user  staff  320 May 24 18:07 build
-rw-r--r--   1 gradle-user  staff  862 May 24 17:45 build.gradle.kts
drwxr-xr-x   4 gradle-user  staff  128 May 24 17:45 src
----

All the files generated by the build process go into the `build` directory unless otherwise specified.

== Step 4. Understanding Gradle's Project Structure

Let's take a look at a standard Gradle project structure and compare it to our tutorial project:

image::tutorial/project-structure.png[]

A *build* contains:

1. A top level `settings.gradle.kts` file.
2. A *root project*.
3. One or more *subprojects*, each with its own `build.gradle.kts` file.

Some builds may contain a `build.gradle.kts` file in the root project but this is NOT recommended.

The `libs.version.toml` file is a version catalog used for dependency management which you will learn about in a subsequent section of the tutorial.

In this tutorial:

1. The *root project* is called *tutorial* and is defined with `rootProject.name = "tutorial"` in the `settings.gradle` file.
2. The *subproject* is called *app* and is defined with `include("app")` in the `settings.gradle` file.

The root project can be in the top-level directory or have its own directory.

A build:

- Represents a bundle of related software that you can build, test, and/or release together.
- Can optionally include other builds (i.e. additional software such as libraries, plugins, build-time tools, etc).

A project:

- Represents a single piece of your architecture - a library, an app, a Gradle plugin, etc.
- Can optionally contain other projects.

== Step 5. Viewing Gradle files in an IDE
Open the project in IntelliJ IDEA by double-clicking on the `settings.gradle.kts` file in the `tutorial` directory:

image::tutorial/intellij-idea-ide.png[]

Open the `settings.gradle.kts` and `build.gradle.kts` files in the IDE:

image::tutorial/intellij-idea-open.png[]

== Step 6. Understanding the Settings file
A project is composed of one or more subprojects (sometimes called modules).

Gradle reads the `settings.gradle.kts` file to figure out which subprojects comprise a project build.

Take a look at the file in your project:
[source,kotlin]
----
plugins {
    // Apply the foojay-resolver plugin to allow automatic download of JDKs
    id("org.gradle.toolchains.foojay-resolver-convention") version "0.8.0"
}

rootProject.name = "tutorial"
include("app")
----

The `tutorial` root project includes the `app` subproject.
The presence of the `include` call turns the `app` directory into a subproject.

== Step 7. Understanding the Build script
Each subproject contains its own `build.gradle.kts` file.

The `build.gradle.kts` file is the core component of the build process and defines the tasks necessary to build the project.

The `build.gradle.kts` file is read and executed by Gradle.

Take a closer look at the build file in your `app` subproject (under the `app` directory):
[source,kotlin]
----
plugins {
    // Apply the application plugin to add support for building a CLI application in Java.
    application
}

repositories {
    // Use Maven Central for resolving dependencies.
    mavenCentral()
}

dependencies {
    // Use JUnit Jupiter for testing.
    testImplementation("org.junit.jupiter:junit-jupiter:5.9.1")

    // This dependency is used by the application.
    implementation("com.google.guava:guava:32.1.2-jre")
}

// Apply a specific Java toolchain to ease working on different environments.
java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(11)
    }
}

application {
    // Define the main class for the application.
    mainClass = "org.example.App"
}

tasks.named<Test>("test") {
    // Use JUnit Platform for unit tests.
    useJUnitPlatform()
}
----

This build script lets Gradle know which dependencies and plugins the `app` subproject is using and where to find them.
We will look at this in more detail in the following sections.

[.text-right]
**Next Step:** <<part2_gradle_tasks#part2_begin,Running Tasks>> >>
